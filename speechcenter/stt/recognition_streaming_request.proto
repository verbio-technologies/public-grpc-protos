syntax = "proto3";

package speechcenter.recognizer.v1;


// The contract for streaming recognition requests.
// The stream must begin with a single `RecognitionConfig` message.
// Subsequent messages may contain `audio` (raw bytes) or `event_message` (control signals).
// To close the stream properly, the client must send an `EventMessage` of type `END_OF_STREAM`.
message RecognitionStreamingRequest {
    oneof recognition_request {
        // The initial configuration message. Must be the first message sent in the stream.
        RecognitionConfig config = 1;

        // A chunk of raw audio data in the selected format.
        bytes audio = 2;

        // A control message to signal specific events during the stream.
        EventMessage event_message = 3;
    }
}

// The initialization message containing recognition parameters.
message RecognitionConfig {
    enum AsrVersion {
        V1 = 0;
        V2 = 1;
    }

    // General parameters for the recognition (e.g., language, audio format).
    RecognitionParameters parameters = 1;

    // The recognition resource (topic or grammar) to be used.
    RecognitionResource resource = 2;

    // The version of the speech recognition engine. 
    // Versions may support different languages, topics, and features.
    AsrVersion version = 3;

    // Timer configurations for MRCP-like behavior.
    optional TimerConfiguration configuration = 4;

    // Labels to apply to this recognition for billing and grouping purposes.
    // Up to 1 label is allowed, with a maximum of 128 characters.
    repeated string label = 5;
}

message RecognitionParameters {
    // The language locale of the audio in IETF BCP 47 format (e.g., "en-US").
    // Supported languages vary by AsrVersion.
    string language = 1;

    oneof AudioEncoding {
        // Linear Pulse-Code Modulation (signed 16-bit samples, little-endian).
        PCM pcm = 2;
    }

    // The number of audio channels. Set this if speaker separation per channel is desired.
    optional uint32 audio_channels_number = 3;

    // If true, enables output formatting (punctuation, capitalization). 
    // Only available for certain languages. Premium feature on V1.
    bool enable_formatting = 4;

    // If true, enables speaker diarization. Premium feature on V1.
    bool enable_diarization = 5;
}

message PCM {
    // The audio sample rate in Hertz.
    uint32 sample_rate_hz = 1;
}

// Specifies the domain model or grammar for recognition.
message RecognitionResource {
    enum Topic {
        // Suitable for generic speech.
        GENERIC = 0;
        // Optimized for banking recordings.
        BANKING = 1;
        // Optimized for telecommunications.
        TELCO = 2;
        // Optimized for insurance.
        INSURANCE = 3;
    }

    oneof Resource {
        // A pre-defined topic model to use for recognition.
        Topic topic = 1;

        // An ABNF grammar resource.
        GrammarResource grammar = 2;
    }
}

message GrammarResource {
    oneof Grammar {
        // The ABNF grammar text provided inline.
        string inline_grammar = 1;

        // A URI pointing to a grammar provided by online Verbio services.
        string grammar_uri = 2;

        // A binary grammar precompiled by Verbio services.
        bytes compiled_grammar = 3;
    }
}

message TimerConfiguration {
    // The duration in milliseconds to wait for speech detection.
    // If no speech is detected within this time, the operation ends with a "No Match" cause.
    optional uint32 recognition_timeout = 1;

    // If false, input timers will not start until an `EventMessage` 
    // of type `START_INPUT_TIMERS` is received.
    optional bool start_input_timers = 2;

    // The duration in milliseconds to wait for more speech after a complete result is detected.
    optional uint32 speech_complete_timeout = 3;

    // The duration in milliseconds to wait for more speech when only a partial result is detected.
    // Unlike `recognition_timeout`, this returns a partial match rather than "No Match".
    optional uint32 speech_incomplete_timeout = 4;
}

message EventMessage {
    enum Event {
        // Signals the server to start the input timers.
        START_INPUT_TIMERS = 0;
        // Signals the server that no further audio will be sent.
        END_OF_STREAM = 1;
    }

    // The type of event being signaled.
    Event event = 1;
}